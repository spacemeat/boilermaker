$<out $enumsHeaderPath>$+
#pragma once

$headerTopComment

#include "$commonHeaderFile"
$+
$<join for inc in $enumHeaderIncludes>$+
#include $inc
$<endjoin>
$''
$+


$+$<join for enum in $enums>$+
    $<if not $enum.alreadyDefined>
        $<set scope as $scope + '::' + $namespaceForCode>
namespace $namespaceForCode
{
    enum $<if $enum.isScoped()>class $<endif>$<$enum.codeDecl>
    {
        $<join for val in $enum.vals>$+
        $+  $<if $val.numberValueSpecified>$+
        $<$val.codeDecl> = $<$val.numberValue>$+
        $+  $<else>$+
        $<$val.codeDecl>$+
        $+  $<endif>$<delim>,
        $<endjoin>$''
    };
}$<endset>
$<endif>
$<endjoin>
$+

$+  $<if 'humon' in $enumDeserializeFrom>
$<set scope as $scope + '::hu'>
namespace hu
{
    $+  $<join for enum in $enums>
    template <>
    struct val<$<$rescope($enum)>>
    {
        static inline $<$rescope($enum)> extract($<$const('Node')> & node) noexcept
        {
            $+  $<if not $enumFlags>
            auto nodeVal = node.value().str().data();
            $+  $<join for val in $enum.vals>$+
            if (std::strncmp(nodeVal, "$<$val.bomaName>", $<len($val.bomaName)>) == 0) { return $+
            $<if $enumIsScoped>$+
                $<$rescope($enum)>::$<$val.codeDecl>$+
            $<else>$+
                $<$rescope($val)>$+
            $<endif>$+
                    ; }
            $<endjoin>$+
            return {};$+
            $<else>
            using enumIntType = std::underlying_type<$<$rescope($enum)>>::type;
            enumIntType e = 0;
            bool fromList = node.kind() == hu::NodeKind::list;
            Node chNode = node;
            if (fromList)
                { chNode = chNode.firstChild(); }
            do
            {
                auto nodeVal = chNode.value().str().data();
                if      $<join for val in $enum.vals>$+
                (std::strncmp(nodeVal, "$<$val.bomaName>", $<len($val.bomaName)>) == 0) { e |= static_cast<enumIntType>($+
                $<if $enumIsScoped>$+
                    $<$rescope($enum)>::$<$val.codeDecl>$+
                $<else>$+
                    $<$rescope($val)>$+
                $<endif>$+
                ); }$+
                $<delim>$''
                else if $<endjoin>$''
                chNode = chNode.nextSibling();
            }
            while(fromList && chNode);
            return static_cast<$<$rescope($enum)>>(e);$+
            $<endif $<# enum.flags>>$''
        }
    };
$<endjoin>$+  $<# enum>
}
$<endset>$<endif>$+  $<# humon>
$<set scope as $scope + '::' + $sharedCodeNamespaceForCode>
$<if 'humon' in $enumSerializeTo or ('binary' in $enumDeserializeFrom and len($enums) $> 0)>$+
namespace $sharedCodeNamespaceForCode
{
    $+  $<if 'binary' in $enumDeserializeFrom and len($enums) $> 0>
    template <class T>
    struct BinaryReader<T, typename std::enable_if_t<std::is_enum_v<T>>>
    {
        static inline T extract(const char *& buffer, std::size_t & size)
        {$+
            $<if 'deserializeBinary' in $caveperson>
            $caveStream << "Reading enum\n";$<endif>$+
            $<if $checkBinaryOverruns>
            if (size < sizeof(T))
                { throw std::runtime_error("Binary buffer too small."); }$+
            $<endif>
            auto t = * reinterpret_cast<const T *>(buffer);
            buffer += sizeof(T);
            size -= sizeof(T);
            return t;
        }
    };
$<endif>
    $+
$<if 'humon' in $enumSerializeTo>$+
$+  $<join for enum in $enums>$+
    std::ostream & operator <<(std::ostream & out, $<$const('HumonFormat<' + $rescope($enum) + '$>')> & obj);
    $<endjoin>
}
$<endif $<# humon>>$+
$<endif $<# binary or humon>>$+
$<endset>$+
$<endout>$+
