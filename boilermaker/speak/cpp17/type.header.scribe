$<join for type in $types>
------------------ Building $headerDir/$typeHeaderFile.
$<out $headerDir + '/' + $typeHeaderFile>$+
#pragma once

$headerTopComment

$<join for header in $<$includes.type.header>>
#include $header$<endjoin>

namespace $namespace
{
    $<$type.typetype> $<$type.name>;$<if $swap>
    void swap($<$type.name> & lhs, $<$type.name> & rhs) noexcept;$<endif>$<if 'humon' in $serializeTo>
    std::ostream & operator <<(std::ostream & out, $<$const('HumonFormat<$<$type.name>$>)> & obj');$<endif>$<if 'binary' in $serializeTo>
    std::ostream & operator <<(std::ostream & out, $<$const('BinaryFormat<$<$type.name>$>)> & obj');$<endif>$<if $comparable>
    bool operator ==($<$const($<$type.name>)> & lhs, $<$const($<$type.name>)> & rhs);
    bool operator !=($<$const($<$type.name>)> & lhs, $<$const($<$type.name>)> & rhs);$<endif>
$<if $diffable>
    template<>
    struct Diff<$<$type.name>$>
    {$<if $type.members.length $> 0>
        enum class Members : std::size_t
        {
$<join for member in $type.members>$tab$tab$tab$<$member.name>,$<delim>
$<endjoin>
            numMembers
        };

        Diff();
        Diff($<$const($<$type.name>)> & lhs, $<$const($<$type.name>)> & rhs);

        std::bitset<static<cast<std::size_t>(Members::numMembers)> memberDiffs;$<endif>$<join for member in type.members>
        Diff<$<$member.type>$> $<$member.name>_diffs;$<endjoin>
    };$<endif>

    $<$type.typetype> $<$type.name>
    {$<if $<$type.typetype> == 'class'>
    public:$<endif>$<if $defaultConstructible>
        $<$type.name>();$<endif>$<if $memberwiseConstructible>
        $<$type.name>($<join for member in $<$type.members>>$<$const($<$member.type.name>)> & $<$member.name>$<delim>, $<endjoin>);$<endif>$<if 'humon' in $deserializeFrom>
        $<$type.name>($<$const('hu::Node')> & node);$<endif>$<if 'binary' in $deserializeFrom>
        $<$type.name>($<$const('char *')> & buffer, std::size_t & size);$<endif>$<if $copy != 'omit'>
        $<$type.name>($<$const($<$type.name>)> & rhs)$<if $copy == 'default'> default$<elif copy == delete> delete$<endif>;$<endif>$<if $move != omit>
        $<$type.name>($<$type.name> && rhs)$<if $move == 'default'> default$<elif move == 'delete'> delete$<else> noexcept$<endif>;$<endif>$<if $copy != omit>
        $<$type.name> & operator =($<$const($<$type.name>)> & rhs)$<if $copy == 'default'> default$<elif copy == delete> delete$<endif>;$<endif>$<if $move != omit>
        $<$type.name> & operator =($<$type.name> && rhs)$<if $move == 'default'> default$<elif move == 'delete'> delete$<else> noexcept$<endif>;$<endif>$<if $destructor != omit>
        $<if $destructor == virtual>virtual $<endif>~$<$type.name>()$<if $destructor == 'default'> = default$<elif destructor == 'delete'> = delete$<endif>;$<endif>$<if $swap>
        friend void swap($<$type.name> & lhs, $<$type.name> & rhs) noexcept;$<endif>$<join for member in $type.members>$<if $getters>
        $<$member.type.name>         get_$<$member.name>() &&$<if $inlineGetters>      { return $<$member.name>; }$<else>;$<endif>$<endif>$<if $constGetters>
        $<$const($member.type.name>) & get_$<$member.name>() const &$<if $inlineGetters> { return $<$member.name>; }$<else>;$<endif>$<endif>$<if $nonConstGetters>
`        $<$member.type.name>       & get_$<$member.name>() &$<if $inlineGetters>       { return $<$member.name>; }$<else>;$<endif>$<endif>$<endjoin>$<join for member in $<$type.members>>$<if $setByCopy>
        void set_$<$member.name>($<$const($member.type.name)> & new_$<$member.name>)$<if $inlineSetters>  { $<if $copyByCopySwap>using std::swap; swap($<$member.name>, new_$<$member.name>);$<else>$<$member.name> = new_$<$member.name>;$<endif> }$<else>;$<endif>$<endif>$<if $setByMove>
        void set_$<$member.name>($<$member.type.name> && new_$<$member.name>)$<if 'humon' in $inlineSetters>         { $<if $copyByCopySwap>using std::swap; swap($<$member.name>, new_$<$member.name>);$<else>$<$member.name> = std::move(new_$<$member.name>);$<endif> }$<else>;$<endif>$<endif>$<endjoin>$<if $serializeTo>
`        friend std::ostream & operator <<(std::ostream & out, $<$const('HumonFormat<$<$type.name>>)> & obj')>;$<endif>$<if 'binary' in $serializeTo>
        friend std::ostream & operator <<(std::ostream & out, $<$const('BinaryFormat<$<$type.name>>)> & obj')>;$<endif>$<if $comparable>
        friend bool operator ==($<$const($<$type.name>)> & lhs, $<$const($<$type.name>)> & rhs);
        friend bool operator !=($<$const($<$type.name>)> & lhs, $<$const($<$type.name>)> & rhs);$<endif>$<if $diffable>
        friend Diff<$<$type.name>>::Diff();
        friend Diff<$<$type.name>>::Diff($<$const($<$type.name>)> & lhs, $<$const($<$type.name>)> & rhs);$<endif>
$<if $privateMembers>
    private:$<endif>$<join for member in $<$type.members>>
        $<$member.type> $<$member.name>;$<endjoin>
    };
$<if 'humon' in $deserializeFrom>
namespace hu
{
    template<>
    struct val<$namespace::$<$type.name>>
    {
        static inline val<$namespace::$<$type.name> extract($<$const('Node')> & node)
        {
            return val<$namespace::$<$type.name>(node);
        }
    };
}
$<endif>$<if 'binary' in $deserializeFrom>
namespace $namespace
{
    template <$>
    struct BinaryReader<$<$type.name>$>
    {
        static inline $<$type.name> extract($<$const('char *')>& buffer, std::size_t & size)
        {
            return $<$type.name>(buffer, size);
        }
    };
}
$<endif>$<endout>$<endjoin>
